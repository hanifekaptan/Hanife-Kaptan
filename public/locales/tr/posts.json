{
  "mainTitle": "Blog Yazılarım",
  "mainSubtitle": "Teknoloji, yapay zeka ve yazılım geliştirme üzerine düşüncelerim ve notlarım.",
  "readMoreText": "Devamını Oku →",
  "seeAllText": "Tüm Yazıları Gör",
  "noPostsFound": "Aradığınız kriterlere uygun yazı bulunamadı.",
  "searchPlaceholder": "Yazılarda ara...",
  "filterByCategoryTitle": "Kategori",
  "filterBySortTitle": "Sırala",
  "sortNewest": "En Yeni",
  "sortOldest": "En Eski",

  "python-ile-whatsapp-mesaji-gondermek": {
    "title": "PYTHON İLE WHATSAPP MESAJI GÖNDERMEK",
    "summary": "Bir işletmeniz varsa ve satış değerlerinizi arttırmak istiyorsanız WhatsApp kullanımı satışlarınızı gözle görülür oranda arttırabilir.",
    "content": "<p>Bir işletmeniz varsa ve satış değerlerinizi arttırmak istiyorsanız WhatsApp kullanımı satışlarınızı gözle görülür oranda arttırabilir. Gözlemlenen değerlere göre WhatsApp kullanımı satışları %127 oranına çıkarabilir ve müşteri hizmetlerini %225 oranında geliştirebilir. Küçük işletmeler, müşterilere kısa sürede cevap verme kolaylığına sahipken daha büyük işletmelerde cevap verme süresinin arttığını gözlemleyebiliriz. Bu durum müşteri ilişkilerini kötü etkilemesi sebebiyle hem müşteriler hem de işletmeler için istenmeyen bir durumdur. Bu gibi veya çeşitli sebeplerle WhatsApp uygulamasında gelişmiş otomatik mesaj senaryoları kullanmak isteyebiliriz.</p><p>Bu yazımda otomatik mesaj senaryolarının bir parçası olan mesaj gönderme işlemini, Python programlama dili ile nasıl yapabileceğimizi avantajlı ve dezavantajlı yönlerini ele alarak 2 farklı yöntemle anlatacağım.</p><p>Anlatacağım ilk yöntem “selenium”, “whatsapp-web” ve “pyautogui” modüllerini kullanmamızı gerektiriyor. Eğer bu modülleri daha önce yüklemediyseniz aşağıdaki komutları sırayla terminalde çalıştırmanız gerekebilir.</p><pre><code>pip install selenium\npip install whatsapp-web\npip install pyautogui</code></pre><p>Kullanacağımız modülleri uygulamamıza dahil edelim.</p><pre><code>from selenium import webdriver\nfrom simon.account.pages import LoginPage\nfrom simon.header.pages import HeaderPage\nimport pyautogui as pg\nimport time</code></pre><p>Selenium WebDriver modülü tercih ettiğimiz web tarayıcısıyla etkileşime geçmemizi sağlar. Ben Chrome tarayıcısını kullanacağım, siz de kendinize uygun olan ile devam edebilirsiniz.</p><pre><code>tarayici = webdriver.Chrome()</code></pre><p>Whatsapp-web modülünün LoginPage ve HeaderPage sınıflarını WhatsApp Web’e giriş ve çıkış işlemlerinde kullanacağız. Her iki sınıf da parametre olarak tarayıcı nesnesini alır. Load fonksiyonuyla WhatsApp Web’in giriş sayfasını açar, remember_me özelliğiyle beni hatırla seçeneğini işaretleyebiliriz. Bu adımda giriş yapabilmek için, mobil uygulamadan QR kodu taramamız gerekir.</p><pre><code>giris = LoginPage(tarayici)\ngiris.load()\ngiris.remember_me = False</code></pre><p>Bu noktada dikkat etmemiz gereken bir husus var. Uygulamalar, çalıştırıldıktan sonra herhangi bir adımda biz bekleme süresi eklemediysek kendileri durup diğer adımın gerçekleşmesini beklemezler. Ancak biz WhatsApp Web giriş ekranında birkaç saniye durup, mobil cihazımızdan karekodu okutacak ve bizim için az ancak uygulamanın çalışmasını engelleyecek kadar fazla bir süre beklemiş olacağız. Bir sonraki adımda kodlarımıza time modülünden yararlanarak bekleme süresi ekleyeceğiz.</p><p>Pyautogui modülü bilgisayar ekranında çeşitli işlemler yapabilmemizi sağlar. Dikkat etmemiz gereken şey mesaj yazma ve gönderme işlemlerini gerçekleştirirken işlemin yapılacağı sayfanın açık olması gerektiğidir. Yani herhangi başka bir yolu tercih etmiyorsak (bu yazıda değinmesek de whatsapp-web modülünün diğer sınıflarından faydalanarak istediğimiz sohbeti açabiliriz), mesajı göndereceğimiz kişi ya da grup sohbeti mesaj gönderilmeden önce manuel olarak ekranda açılmalıdır. Bu durum, karekod okutup giriş yaparken olduğu gibi vakit alan ve programın akışını engelleyebilecek başka bir durumdur. Bu sebeplerden dolayı hem giriş yapabilmek hem de mesajı göndermek istediğimiz sohbeti açabilmek için makul bir bekleme süresi ekleyerek devam edelim.</p><pre><code>time.sleep(30)</code></pre><p>Mesaj değişkeni göndereceğimiz mesaj metnini ifade ediyor. Write değişkeniyle mesajı yazılacak ve press fonksiyonuyla “enter” tuşuna basılacak yani mesaj gönderilmiş olacak.</p><pre><code>mesaj = “Hello world”\npg.write(mesaj)\npg.press(“Enter”)</code></pre><p>Mesajı gönderdikten sonra WhatsApp Web uygulamasından çıkış yapmamız ve tarayıcıyı kapatmamız gerekir. Bunu da aşağıdaki kod bloklarıyla yapabiliriz.</p><pre><code>cikis = HeaderPage(tarayici)\ncikis.logout()\ntarayici.quit()</code></pre><p>Bu şekilde, Python ile bir WhatsApp mesajı gönderme yollarından birini öğrendik. Bu yöntem daha çok kullanıcı müdahalesi gerektiren ve tamamen otomatize edilememiş bir yöntem olması bakımından dezavantajlıdır. Birçok kişiye birden fazla mesaj göndermek istediğimizde gerektiğinden fazla zaman kaybına sebebiyet verebilir veya gerektiğinden uzun kod bloklarıyla çalışmak zorunda kalabiliriz. Tek bir kişiye gönderilen birden fazla mesajlar ise daha basit bir şekilde yönetilebilir. Tamamen ücretsiz olması bu yöntemin avantajlarından biridir.</p><p>Whatsapp-web modülünü kullanarak da WhatsApp üzerinden mesaj gönderebiliriz. Bu konuda detaylı bilgiye erişmek için aşağıdaki linkten faydalanabilirsiniz:</p><p><a href='https://pypi.org/project/whatsapp-web/' target='_blank' rel='noopener noreferrer'>whatsapp-web A Python library to automate easily whatsapp web pypi.org</a></p><p>Öğreneceğimiz ikinci yöntem ise whatsapp_api_client_python modülüyle ile bir WhatsApp mesajı göndermektir. Bu modülü kullanabilmek için öncelikle Green-API’nin sitesinden bir üyelik oluşturmalıyız. Üyelik oluşturduktan sonra karşımıza çıkan sayfadaki karekodu mobil WhatsApp uygulamasından okutarak yetkilendirme işlemi yapmalıyız. Bu aşamaları tamamladıktan sonra uygulama üzerinden hesabımıza erişebilmek için Id Instance ve API Token Instance bilgilerini not ederek Green API’yi kapatabiliriz.</p><p>Green API’yi Python uygulamamızda kullanmak için öncelikle terminalden yükleyelim.</p><pre><code>pip install whatsapp_api_client_python</code></pre><p>Yükleme işlemi tamamlandığında uygulamamıza import edebiliriz. Bu API ile WhatsApp Web’i açmadan veya herhangi bir kullanıcı müdahalesi gerektirmeden mesaj gönderebileceğiz.</p><pre><code>from whatsapp_api_client_python import API</code></pre><p>Not ettiğimiz Id Instance ve API Token Instance bilgilerini kullanarak değişkenler oluşturalım. Bunlar Green API kimliğimizi ifade eden değişkenler. Ardından bir GreenAPI nesnesi oluşturacağız. Bu nesne üzerinden mesaj gönderme işlemlerini gerçekleştireceğiz.</p><pre><code>idInstance = \"**********\"\napiTokenInstance = \"**************************************************\"\ngreenAPI = API.GreenAPI(idInstance, apiTokenInstance)</code></pre><p>Mesaj göndermek için ülke alan koduyla birlikte mesaj göndereceğimiz kişinin telefon numarasını giriyoruz. sendMessage fonksiyonu, telefon numarası ve mesaj parametrelerini alarak mesaj göndermeyi sağlar ancak telefon numarasına “@c.us” ekleyerek yazmalıyız. Bu şekilde mesaj gönderim işlemi tamamlanır.</p><pre><code>number = \"905*********\"\ngreenAPI.sending.sendMessage(\"{@c.us\">number}@c.us\", \"hi friend\")</code></pre><p>Bu şekilde, Python ile WhatsApp mesajı göndermenin yollarından ikincisini öğrendik. Bu yöntem tamamen otomatize edilebilirliği bakımından avantajlıdır. Birçok kişiye birden fazla mesaj göndermek istediğimizde kolaylıkla ve zaman kaybı yaşamadan işlemleri gerçekleştirebilir ve uzun kod bloklarıyla çalışmayız. Geliştiriciler için ücretsiz tarifesi vardır ve bu tarifeye göre ayda 3 farklı kişiye toplam 100 mesaj gönderme sınırı vardır. Ancak ihtiyaçlarımız bundan fazlaysa ücretli tarifeler tercih edilmelidir. Ücretli olması bu yöntemin dezavantajlı yönlerinden biridir.</p><p>Green API kullanarak fotoğraf, link, dosya veya konum gönderebiliriz. Ayrıca önceki mesajlara erişebilir ve mesajları işaretleyerek yanıtlamak da mümkündür. Bunlara ek olarak mesaj gönderildiği gibi verilen cevapları almak da greenAPI.webhook.receiver ile sağlanır. Green API hakkında daha fazla bilgi edinmek için aşağıdaki yazıdan faydalanabilirsiniz.</p><p><a href='https://pypi.org/project/whatsapp-api-client-python/' target='_blank' rel='noopener noreferrer'>whatsapp-api-client-python This library helps you easily create a Python application with WhatsApp API. pypi.org</a></p><h3>Kaynakça:</h3><ol><li>https://codewithcurious.com/projects/send-whatsapp-messages-using-python/</li><li>https://pypi.org/project/whatsapp-web/</li><li>https://pypi.org/project/whatsapp-api-client-python/</li><li>https://console.green-api.com/instanceList</li></ol>"
  },
  "json-verileriyle-calismak": {
    "title": "JSON VERİLERİYLE ÇALIŞMAK",
    "summary": "Parçası olduğumuz bir proje veya çalıştığımız bir işte çeşitli veriler elde ederiz. Birçok zaman bu verileri bir şekilde depolamamız gerekir.",
    "content": "<p>Parçası olduğumuz bir proje veya çalıştığımız bir işte çeşitli veriler elde ederiz. Birçok zaman bu verileri bir şekilde depolamamız gerekir. Günümüzde verileri depolamak için tercih edilen birçok yöntem vardır ve dahil olduğumuz proje veya çalıştığımız işe göre en uygun olanını seçmek önemli bir husustur. Verilerin büyüklüğü, veri tipleri, veri güvenliği, sektörde tercih edilen veri saklama eğilimleri, iş veya proje büyüklüğü ve bu iş için ayrılan bütçe gibi şirket gereksinimleri veri saklama tercihlerini etkileyen unsurlardandır. İlişkisel ve ilişkisel olmayan veritabanı sistemleri, bulut sistemleri veya dosyalama sistemleri veri depolama yöntemlerinden birkaçıdır. Her birinin avantajlı ve dezavantajlı yönleri vardır. Genellikle küçük iş ve uygulamalarda ve API çıktılarında daha basit yapılı olması ve doğrudan ulaşılabilir olması sebebiyle dosyalama sistemleri tercih edilmektedir. Ayrıca dosya sistemleri de kendi içinde farklı alternatiflere sahiptir. Elimizdeki verileri Excel dosyası, csv dosyası, JSON dosyası gibi farklı dosya türlerinde de saklayabiliriz.</p><p>Bu yazımda JSON verileriyle çalışmaktan bahsedecek ve JSON nedir, Python sözlük (dictionary) veri tipi ve JSON formatı arasındaki fark nedir, veriler JSON formatında nasıl yazılır, JSON formatındaki veriler nasıl okunur, program içindeki bir sözlük verisini nasıl JSON formatına dönüştürülür, gibi soruları cevaplayacağım.</p><p>JSON yani JavaScript Object Notation, hem insan hem de makine tarafından okunabilen açık bir veri değişim formatıdır. String, array, boolean, object, null ve sayı türündeki veri tiplerini destekler, dilden bağımsızdır. JSON verilerini daha iyi anlayabilmek için bir örnek üzerinden gideceğiz. Aşağıdaki gibi bir dosya oluşturalım:</p><p>“FilozofSpinoza.json”</p><p>Öncelikle bu dosyanın içine saklamak istediğimiz verileri yazacak, daha sonra bunu Python kodları yazarak programımıza dahil edecek ve neler yapabileceğimize göz atacağız.</p><p>JSON verisi yazmak hakkında bilinmesi gereken ilk şey, verilerin her zaman süslü parantezler ({}) arasına yazılacağıdır. Süslü parantezler, içinde verilerimizi barındıran sınırları temsil eder ve parantezin dışında kalan kısımlara veri yazılmaz.</p><p>Süslü parantezlerin arasına verileri anahtar ve değer çiftleriyle yazarız. Anahtar, verideki değişkenleri (başka bir deyişle sütunları) değer ise verideki gözlemleri (başka bir ifadeyle ilgili sütuna karşılık gelen satır değerini) ifade eder. Anahtar ve değer ifadeleri çift tırnak (“”) arasında yazılır ve birbirlerinden iki nokta (:) ile ayrılır.</p><p>Anahtar ifadeler, yalnızca string olabilir ancak istisna sayılabilecek bir durum olarak herhangi bir string ifade verilmediği takdirde anahtar ifadesinin varsayılan olarak tanımsız sayılacağıdır. Değer ifadesi ise string, sayı, array, boolean, object, null ya da süslü parantezler arasına yazılmış başka bir JSON verisi olabilir. Ayrıca kendinden sonra gelen bir anahtar ifadesi var ise, değer ile anahtarı virgül ile ayırmamız gerekir. Öğrendiklerimiz çerçevesinde basit bir JSON verisini aşağıdaki şekilde yazabiliriz:</p><pre><code>{\n    \"isim\": \"Baruch\",\n    \"soyisim\": \"Spinoza\",\n    \"yas\": 45,\n    \"\": \"Tanımsız\",\n    \"hayatta mi\": False\n}</code></pre><p>Girintilerin kullanımı, veri okunabilirliğini arttırdığı için tavsiye edilir. Peki elimizde Spinoza’nın yazdığı kitaplardan oluşan bir kitap listesi olsaydı bu verileri nasıl yazardık? String veya integer türünde olmayan, array türündeki verileri köşeli parantez ([]) içerisine, her bir değeri virgül ile ayırarak yazarız. Aşağıda bir örnek gösterilmiştir.</p><pre><code>{\n    \"isim\": \"Baruch\",\n    \"soyisim\": \"Spinoza\",\n    \"yas\": 45,\n    \"kitaplari\": [\n        \"Etika\",\n        \"Politik inceleme\",\n        \"Anlama yetisinin düzeltilmesi üzerine inceleme\"\n                 ]\n}</code></pre><p>Bir de doğum, ölüm gibi önemli tarihleri içeren bir tarih değişkeni olduğunu ancak anlaşılır olması için array şeklinde saklamak istemediğimizi düşünelim. Bu veriyi JSON formatında bir değer ifadesi olarak yazabiliriz. Aşağıda örnek kullanım verilmiştir.</p><pre><code>{\n    \"isim\": \"Baruch\",\n    \"soyisim\": \"Spinoza\",\n    \"yas\": 45,\n    \"kitaplari\": [\n        \"Etika\",\n        \"Politik inceleme\",\n        \"Anlama yetisinin düzeltilmesi üzerine inceleme\"\n                 ],\n    \"tarih\": {\n        \"dogum\": \"24.11.1632\",\n        \"olum\": \"21.02.1677\"\n             }\n}</code></pre><p>Şimdiye kadar öğrendiklerimizle Python sözlük (dictionary) veri türü ile JSON verilerinin yazılış ve yapı bakımından birbirlerine oldukça benzediklerini söylemek mümkündür. Bundan hareketle biri için geçerli olan bir kuralın diğeri için de geçerli olduğu düşünülebilir ancak bu hatalı bir yaklaşımdır. Şimdi sözlük veri türü ile JSON verileri arasındaki farkları ele alalım.</p><p>JSON anahtar ifadeleri yalnızca string veri tipinde olabileceğini söylemiştik. Python sözlüklerinde ise durum bu şekilde değildir. Sözlük veri türünde anahtar ifadesi string, integer gibi farklı veri türlerinde olabilir. JSON verilerinde bu, hataya sebep olacak durumlardan biridir.</p><p>JSON anahtar ifadeleri tekrarlanabilir yapıdadır. Yani birden fazla anahtar ifadesi aynı olabilir. Bu kullanımı tavsiye edilmeyen bir durum olsa da dosya hata vermeden çalışır. Python sözlük türü ise buna izin vermez. Sözlüklerde her anahtar ifadesi eşsizdir ve öyle olmadığı durumda hata döndürür. Aşağıda JSON yapısına örnek verilmiştir.</p><pre><code>{\n    \"isim\": \"Baruch\",\n    \"isim\": \"Benedictus de\",\n    \"soyisim\": \"Spinoza\",\n    \"yas\": 45\n}</code></pre><p>Dosyadaki verileri, kimi zaman program içinde kullanmamız gerekebilir. Bir JSON verisini program içinde nasıl okuyacağımızı ileride anlatacağız. Şu an bilmemiz gereken Python ile bir JSON verisi okuduğumuzda, verilerin ilk olarak sözlük türünde bir değişkene atanacağıdır. Yani dosya okunduğunda JSON formatında yazılmış veriler Python sözlük veri türüne dönüşür ve program içinde verileri bu şekilde kullanabilir veya isteğe bağlı olarak çeşitli değişiklikler yapabiliriz. Bundan hareketle aklımıza şu soru gelebilir. Sözlük veri türünde anahtar ifadesi eşsiz olmalıyken JSON’da birden fazla aynı anahtar ifadesi kullanılabiliyor. Bu durum, bir hataya sebep olmuyor mu veya program bunu nasıl okuyor? Cevaba gelecek olursak hayır, bu durum programda herhangi bir hataya sebep olmuyor. Çünkü program bu verileri okurken sözlükte ilgili anahtar değeri güncellemiş gibi hareket ediyor. Yani anahtar ifadesi tekrarlanmıyor ve kendisine verilen son değeri alıyor. Öyleyse yukarıdaki örneğin Python çıktısının şöyle olmasını bekleriz:</p><p>{\"isim”: “Benedictus de”, “soyisim”: “Spinoza”, “yas”: “45”}</p><p>Son olarak JSON verileri string veriler için sadece çift tırnak kullanımını destekler. Buna karşın Python’da string verileri tek tırnak, çift tırnak veya 3 çift tırnak ile ifade edebiliriz.</p><p>Bu noktaya kadar JSON nedir, JSON verisi nasıl yazılır ve Python sözlükleri ile JSON verileri arasındaki fark nedir gibi konuları ele aldık. Ancak verileri sadece saklamayız ve bunları programımızda kullanmamız veya yeni verilerle birlikte yeniden yazmamız gerekebilir. Bunu programımıza dahil edeceğimiz “json” modülü sayesinde yapacağız. Öncelikle “json” modülünü programımıza “import” edelim.</p><pre><code>import json</code></pre><p>Bu modülde, kullanacağımız 4 fonksiyondan bahsedeceğiz:</p><p><strong>Load:</strong> Verileri JSON dosyasından okur ve Python sözlük türünde bir değişkene atar. Parametre olarak dosya yolunu alır. Eğer JSON dosyası, uygulamamızla aynı dizinde yer alıyorsa parametre olarak sadece dosya adını da kullanabiliriz.</p><pre><code>with open(\"FilozofSpinoza.json\") as dosya:\n    veri= json.load(dosya)</code></pre><p><strong>Loads:</strong> Verileri JSON formunda yazılmış string türündeki değişkenden okur ve Python sözlük türünde bir değişkene atar. Parametre olarak string türündeki veri değişkenini alır.</p><pre><code>jsonVeri = \"\"\"{ \n    \"isim\": \"Baruch\",\n    \"soyisim\": \"Spinoza\",\n    ...\n                }\"\"\"\nveri = json.loads(jsonVeri)</code></pre><p><strong>Dump:</strong> Sözlük türündeki veriyi JSON dosyasına dönüştürür. Parametre olarak sözlük türündeki veriyi ve dosya yolunu alır. Eğer verileri yazacağımız dosya boş bir dosya değilse, dosyadaki verileri kaybetmemek ve dosyanın mevcut yapısını koruyabilmek için doğru dosya işlemleri yapılması konusunda dikkatli olunmalıdır.</p><pre><code>veri = {\n    \"isim\": \"Baruch\",\n    ...\n        }\n\nwith open(\"FilozofSpinoza.json\", \"w\") as dosya:\n    json.dump(veri, dosya)</code></pre><p><strong>Dumps:</strong> Sözlük türü veriyi JSON formatında yazılmış string türündeki değişkene dönüştürür. Parametre olarak sözlük türündeki veri değişkenini alır.</p><p>Dump ve Dumps fonksiyonlarında verileri okunabilir ve düzenli bir şekilde yazdırmak isteyebiliriz. Bunun için girintileri ifade eden ve integer bir değer alan indent parametresini (genellikle 4 değerini alır çünkü 4 space 1 tab ifadesine eşittir) ve alfabetik olarak sıralama işlemi yapan ve boolean bir değer alan sort_keys (varsayılan değeri False’tur, sıralama yapmak için True değeri alır) parametresini kullanırız.</p><pre><code>veri = {\n    \"isim\": \"Baruch\",\n    ...\n        }\n\njsonVeri = json.dumps(veri, indent= 4, sort_keys= True)</code></pre><p>Böylece, JSON verisi nedir, JSON verileri ile sözlük veri türü arasındaki fark nedir, bir JSON verisi nasıl okunur ve yazılır, sözlük veri türündeki bir veri nasıl JSON verisine dönüştürülür sorularını cevaplandırdık ve JSON dosyalarıyla nasıl çalışıldığını öğrendik.</p><h3>Kaynakça:</h3><ol><li>https://www.geeksforgeeks.org/difference-between-json-and-dictionary-in-python/</li><li>https://www.geeksforgeeks.org/python-difference-between-json-dump-and-json-dumps/</li><li>https://www.geeksforgeeks.org/python-difference-between-json-load-and-json-loads/</li><li>https://kerteriz.net/python-json-okuma-yazma-donusturme-islemleri/</li><li>https://tr.m.wikipedia.org/wiki/JSON#:~:text=JSON%20(%22JavaScript%20Object%20Notation%22,bir%C3%A7ok%20ba%C4%9Flam%20ve%20uygulamada%20kullan%C4%B1%C5%9Fl%C4%B1d%C4%B1r.</li><li>https://aws.amazon.com/tr/documentdb/what-is-json/</li></ol>"
  },
  "python-ile-e-mail-gondermek": {
    "title": "PYTHON İLE E-MAIL GÖNDERMEK",
    "summary": "Amerika Birleşik Devletleri’ne bağlı bir kurum olan ARPANET bünyesinde mühendis olan Raymond Samuel Tomlinson’ın 1971 yılında ilk elektronik postayı göndermesiyle e-posta, iletişim dünyasına ilk adımını atmıştır.",
    "content": "<p>Amerika Birleşik Devletleri’ne bağlı bir kurum olan ARPANET bünyesinde mühendis olan Raymond Samuel Tomlinson’ın 1971 yılında ilk elektronik postayı göndermesiyle e-posta, iletişim dünyasına ilk adımını atmıştır. 1976 yılında Malvern’de bulunan telekomünikasyon araştırma merkezini ziyaret eden İngiltere Kraliçesi 2. Elizabeth, adına HME2(Her Majesty Elizabeth 2) takma adıyla açılan mail hesabını kullanarak, e-posta gönderen ilk devlet başkanı olmuştur.</p><p>E-postanın kullanımı zamanla yaygınlaşmıştır. Hatta öyle ki e-postanın icat edilmesinden 7 yıl sonra, 1978 yılında bilgisayar üreticisi olan DEC şirketinde çalışan ve günümüzde spam’in babası olarak anılan Gary Thuerk ARPANET üzerinden neredeyse 400 müşteriye aynı anda toplu e-posta göndermiş ve bu toplu e-posta gönderimiyle 13 milyon dolarlık DEC ürünü satışı gerçekleştirerek elektronik pazarlamanın atası olmuştur.</p><p>E-postanın icat edilmesinden bu yana kullanım yelpazesi günden güne genişlemiş ve genişlemeye devam etmektedir. Günümüzde sıkça işverenler ve çalışanlar arasında, öğrenciler ile öğretmenler arasında, kişisel kullanımlarda, satıcılar ile müşteriler arasında iletişim kurmak veya geri bildirimde bulunmak gibi ve alınan hizmet yahut gerçekleştirilen bir işlemi takip etmek gibi alanlarda kullanılmaktadır. E-posta gönderimi, stratejik ve pratik bir eylem olması nedeniyle çeşitli ihtiyaçlar doğrultusunda çeşitli uygulamalardan yapılabileceği gibi, işlerin hızlandırılmak ve otomatize edilmek istenildiği durumlarda basit kod bloklarıyla yapılabilmesi de mümkündür.</p><p>Bu yazımda “email” kütüphanesini kullanarak nasıl e-posta yazılır ve “smtplib” kütüphanesini kullanarak e-posta nasıl gönderilir sorularını cevaplandıracağım.</p><p>Kod yazma kısmına geçmeden önce kullanıcı bilgilerini korumak için daha güvenli bir alternatif sunan Gmail uygulamasına girerek bir geçiş anahtarı oluşturalım. Bu aşamada, kendi şifrenizi kullanmayı da tercih edebilirsiniz. Geçiş anahtarı özelliğini aşağıdaki cihazlarda oluşturmak mümkündür:</p><ul><li>En az Windows 10, macOS Ventura veya ChromeOS 109 yüklü bir dizüstü ya da masaüstü bilgisayar</li><li>En az iOS 16 veya Android 9 yüklü bir mobil cihaz</li><li>FIDO2 protokolünü destekleyen bir donanım güvenlik anahtarı</li></ul><p>Geçiş anahtarı oluşturabilmek için başka bir önemli husus ise 2 adımlı doğrulamanın açık olmasıdır. Bunun için aşağıdaki yönlendirmeleri takip edebilirsiniz:</p><ol><li>https://myaccount.google.com/ adresini açın</li><li>Gezinme panelinde Güvenlik’i seçin</li><li>“Google’da oturum açma” bölümünden 2 Adımlı Doğrulama> Başlayın’ı seçin</li><li>Ekranda gösterilen adımları uygulayın.</li></ol><p>Kullandığınız cihazda geçiş anahtarı oluşturmak için:</p><ol><li>https://myaccount.google.com/signinoptions/passkeys adresine gidin</li><li>Geçiş anahtarı oluşturun> Devam’a dokunun</li></ol><p>JSON dosyası, yazdığımız kodları üçüncü taraf uygulamalarla veya kişilerle paylaşmak için verileri güvenle saklamanın bir yoludur. Bu uygulamada, kişisel bilgileri ve mail bilgilerini içeren “SenderInfo.json” ve “ReceiverInfo.json” dosyaları oluşturacak ve uygulama içinde bu dosyaları okuyarak bilgilere erişeceğiz.</p><p>SenderInfo.json dosyasına göndericinin email hesabını ve geçiş anahtarını/şifresini yazalım.</p><pre><code>{\n    \"email\": \"samplemailaddress@gmail.com\",\n    \"password\": \"16digitsamplepasskey\"\n}</code></pre><p>ReceiverInfo.json dosyasında ise alıcı/alıcıların email hesaplarını, başlık ve mesaj bilgilerini yazalım. Başlık ve mesaj bilgileri, her alıcı için birbirinden farklı mesajlar göndermek istediğimiz durumlarda kolayca ekleme yapabilmek için liste formunda tutulmaktadır. İstek ve ihtiyaçlar doğrultusunda string tipinde de saklanabilir.</p><pre><code>{\n    \"receivers\": [\"samplereceiver1@gmail.com\", \"samplereceiver2@gmail.com\"],\n    \"subject\": [\"sample subject\"],\n    \"message\": [\"sample message\"]\n}</code></pre><p>App.py dosyasını oluşturduktan sonra JSON dosyalarını okuyup değişkenlere atayan aşağıdaki kod bloğunu yazalım.</p><pre><code>import json\n\nwith open(\"SenderInfo.json\") as file:\n    senderInfo = json.load(file)\n\nwith open(\"ReceiverInfo.json\") as file:\n    receiverInfo = json.load(file)</code></pre><p>Ardından e-posta yazmak ve göndermek için gerekli modülleri import edelim.</p><pre><code>import smtplib\nfrom email.message import EmailMessage</code></pre><p>Eğer uygulama bu aşamada hata verirse ilgili modül/modüller bilgisayarınızda mevcut olmayabilir. Terminalde aşağıdaki komutları çalıştırmanız sorunu çözecektir.</p><pre><code>pip install email\npip install smtplib</code></pre><p>Gönderilecek e-postayı içeriğini oluşturmak için mailWriter fonksiyonunu oluşturalım. mailWriter fonksiyonu sender(gönderici), receiver(alıcı), subject(başlık) ve messages(mail gövdesi) parametrelerini alır ve EmailMessage sınıfından bir nesne döndürür. Fonksiyon içinde tanımlanan “mail” değişkeni ise, email modülünün EmailMessage sınıfından türetilmiş bir nesnedir. Bu nesne alıcı, gönderici, mesaj gövdesi, başlık gibi bazı özelliklere sahiptir. Bu özellikler fonksiyonun parametrelerini alır. Eğer mail içeriğinde Türkçe karakter kullanılmışsa mail.set_content(message) satırının altına, mail.encode(“utf-8”) şeklinde ekleme yapılmalıdır.</p><pre><code>def mailWriter(sender:str, receiver:str, subject: str, message: str) -> EmailMessage:\n    mail = EmailMessage()\n    mail[\"From\"] = sender\n    mail[\"To\"] = receiver\n    mail[\"Subject\"] = subject\n    mail.set_content(message)\n    return mail</code></pre><p>Oluşturulan maili göndermek için sendWithSMTP fonksiyonunu oluşturalım. Bu fonksiyon sender(gönderici), password(şifre/geçiş anahtarı), receiver(alıcı) ve messages(mail bilgisi) parametrelerini alır ve smtplib modülü aracılığıyla maili gönderir. Smtp.gmail.com hostuna bağlanmak için 587, 465 ve 25 olmak üzere 3 farklı port ve 2 farklı güvenlik katmanı mevcuttur. Genellikle istemci ve gönderen sunucu arasında SMTP Submission olarak isimlendirilen 587 numaralı port ve TLS güvenlik katmanı yaygın kullanılır. Mail gönderen ve alan sunucular arasında ise 25 numaralı port standart olarak kullanılmaktadır. Yıllar önce Türkiye’deki servis sağlayıcılar spam ile mücadele kapsamında ADSL için kullanılan IP bloklarında 25 numaralı portu kapatma kararı aldığı için istemci ile sunucu arasında 587 numaralı port kullanılmaktadır. İki sunucu arasında mail iletimi güvenli katman ile yapılacaksa SSL veya TLS 465 numaralı port kullanılmaktadır. Örnekte 587 numaralı port ile çalışacağız.</p><pre><code>def sendWithSMTP(sender: str, password: str, receiver: str, message: EmailMessage):\n    with smtplib.SMTP(\"smtp.gmail.com\", 587) as smtp:\n        smtp.starttls()\n        smtp.login(user= sender, password= password)\n        smtp.send_message(from_addr= sender, to_addrs= receiver, msg= message)</code></pre><p>Mail içeriğini hazırlayan ve SMTP Protokolüyle e-postayı gönderen fonksiyonlar var. Son olarak bu işlemleri birden çok kişi için tekrarlayacak şekilde, for döngüsü içinde çalıştıralım. “sender”, “password”, “receivers”, “subject” ve “message” değişkenlerini tanımlayıp, dict tipindeki “senderInfo” ve “receiverInfo” değişkenlerinden ilgili bilgileri alalım. For döngüsüyle alıcılar teker teker dolaşılarak gönderme işlemi tamamlanacak.</p><p>Enumerate yapısı bu kod bloğunda kullanılmamış olsa da farklı kişilere farklı mesajlar gönderilmek istendiğinde “ReceiverInfo.json” dosyasında gerekli değişiklikleri yaptıktan sonra: “subject= subject[e], message= message[e]” şeklinde küçük bir değişiklikle birlikte kullanılabilir.</p><pre><code>sender = str(senderInfo.get(\"email\"))\npassword = str(senderInfo.get(\"password\"))\nreceivers = list(receiverInfo.get(\"receivers\"))\nsubject = list(receiverInfo.get(\"subject\"))\nmessage = list(receiverInfo.get(\"subject\"))\n\nfor e, i in enumerate(receivers):\n    mail = mailWriter(sender= sender,\n        receiver= i,\n        subject= subject[0],\n        message= message[0])\n    sendWithSMTP(sender= sender,\n        password= password,\n        receiver= i,\n        message= mail)</code></pre><p>İnternet bağlantınızın çalışır durumda olup olmadığını kontrol edip dosyayı çalıştırabilirsiniz. Böylece Python ile nasıl mail gönderileceğini öğrenmiş olduk.</p><h3>Kaynakça:</h3><ol><li>https://www.directiq.com/tr/e-postanin-sosyal-ve-teknolojik-evrim-süreci/</li><li>https://www.brandingturkiye.com/dunden-bugune-e-posta-e-mailin-tarihcesi</li><li>https://support.google.com/accounts/answer/185839?hl=tr&co=GENIE.Platform%3DDesktop</li><li>https://support.google.com/accounts/answer/13548313?hk=tr#zippy=%2Cge%C3%A7i%C5%9F-anahtar%C4%B1-olu%C5%9Fturma</li><li>https://www.hosting.com.tr/bilgi-bankasi/smtp-nedir/</li><li>https://docs.python.org/3/library/smtplib.html</li><li>https://docs.python.org/3/library/email.examples.html</li></ol>"
  },
  "veri-yapilari-ve-algoritmalar-giris": {
    "title": "VERİ YAPILARI VE ALGORİTMALAR: GİRİŞ",
    "summary": "Bilgisayarda yapılabilecek her türlü işlem bilgisayar programları sayesinde gerçekleştirilir.",
    "content": "<p>Bilgisayarda yapılabilecek her türlü işlem bilgisayar programları sayesinde gerçekleştirilir. Bu programlar bilgisayar programcıları tarafından yazılan komut ya da komutlar bütününden meydana gelmektedir. Bilgisayar programları basitçe programlama dilleri kullanılarak yazılır ve bir iş veya amacı gerçekleştirmeye yöneliktir. Bu aşamada programların tek bir bileşenden meydana gelmediğini söylemek mümkündür. Bilgisayar programları veya bir program yazılırken dikkate alınması gereken birçok husus vardır. Algoritma, tasarım desenleri ve veri yapıları bunlara örnek olarak verilebilir. Bu ve diğer hususlar, proje yaşam döngüsü boyunca derinlemesine incelenir ve probleme yönelik doğru bir yaklaşımla uygulanırlar.</p><p>Bu yazımda bilgisayar programlarının önemli bir parçası ve ayrıca bilgisayar mühendisliğinin temel derslerinden olan “veri yapıları ve algoritmalar” serisine basit bir giriş yaparak kavramsal çerçeveyi tanıtacağım. Serinin devamında veri yapıları ve algoritmalar dersinin ilerleyen konularını Java programlama dilini kullanarak anlatacağım.</p><p>Program içerisinde veriler, “değişken” adı verilen ve verileri depolamak için kullanılan bellek alanlarında depolanır. Değişkenler isim, tip, değer ve kapsam gibi temel özelliklere sahiptir. İsim, değişkenin belirli kurallarla yazılımcı tarafından tanımlanmasını; değer, değişkenin sakladığı veriyi; kapsam, değişkenin etki alanını yani lokal veya global olmasını ve tip (tür), değişkenin ne tür bir veri sakladığını ifade eder. Değişkenlerde farklı formatlar olmakla birlikte temel veri türleri bulunmaktadır. Bunlara örnek olarak metin, karakter, tam sayı, ondalıklı sayı, mantıksal evet/hayır ve dizi verilebilir.</p><p>Veri yapısı verileri organize etme, saklama, işleme yöntemlerini tanımlayan çeşitli veri gösterimleridir. Yaygın olarak insanlar veri yapısı terimini, veri ögeleri koleksiyonu için organizasyon veya yapılanma anlamında kullanırlar. Bir dizide saklanan 10 tamsayı, bu tam sayıları diziye ekleme ve diziden çıkarma işlemleri, dizideki elemanların birbirleriyle ilişkisi gibi durumlar, veri yapısına örnek olarak gösterilebilir. Yaygın olarak kullanılan ve ilerleyen yazılarda ele alacağım veri yapıları şunlardır: Yığınlar (stacks), kuyruklar (queues), ağaçlar (trees), bağlantılı listeler (linked lists), grafikler (graphs)…</p><p>Veri yapıları, programlamada etkili ve verimli bir veri yönetimi gerçekleştirilmesine olanak sağlar. Uygulama geliştirme sürecinde doğru veri yapısını seçmek, uygulamanın performansını ve kaynak verimliliğini doğrudan etkiler. Zayıf program tasarımcılarının bu analiz adımını görmezden gelip daha çok aşina oldukları ancak soruna uygun olmayan bir veri yapısını uyguladıkları görülebilir. Bunun sonucunda muhtemelen daha maliyetli, kullanımı ve bakımı daha zor ve yavaş bir program meydana gelecektir. Bu durumda çözüm verimsizdir ve çözüm yolunda da verimlilik gözetilmemiştir denilebilir.</p><p>Verimlilik, uygulanılan çözümün, sorunu gerekli kaynak kısıtlamaları içerisinde çözebilmesidir. Kaynak kısıtlamalarına ilgili alan için ayrılmış bütçe, verileri depolamak için mevcut alan ve her bir alt görevi gerçekleştirmek için izin verilen süre örnek gösterilebilir. Bazen sorunlar mevcut kaynak kısıtlamaları içerisinde çözülemeyebilir. Bu durumlarda maliyetin arttığı gözlemlenir çünkü çözümün tükettiği kaynak miktarı, çözümün maliyetini belirleyen unsurdur. Ayrıca bu sorunlarda verimlilik; belirli gereksinimleri karşılayıp karşılamadığına bakılmaksızın çözümün, bilinen alternatiflerinden daha az kaynak gerektirmesi olarak da tanımlanabilir.</p><p>Doğru veri yapısı seçiminde kullanılan çeşitli analiz yöntemleri vardır. Bu yöntemler verilerin özelliklerini, uygulamanın gereksinimlerini, kullanım senaryoları ve performans kriterlerini değerlendirmeyi içerir.</p><p>Yaygın olarak kullanılan bazı analiz yöntemleri şunlardır:</p><ul><li>Zaman Karmaşıklığı Analizi: Bir algoritmanın veya bilgisayar programının verimliliğini değerlendirmek için bir yöntemdir. Asimptotik analiz (Big O Notasyonu) ve Worst-case, Avarage-case, Best-case bu analizin temel kavramlarıdır.</li><li>Uzay Karmaşıklığı Analizi: Bellek kullanımı ve veri yapısının ne kadar bellek tükettiğini analiz eder. Bellek verimliliği özellikle büyük veri setlerinde önemlidir.</li><li>Erişim ve Manipülasyon Hızı: Verilere erişim ve güncelleme hızını incelemek.</li><li>Veri Dağılımı Analizi: Verilerin nasıl dağıldığına bağlı olarak bazı veri yapılarının daha uygun olup olmadığını belirler. Örneğin sıralı veriler için ağaç yapıları daha iyi olabilir.</li><li>Senaryo Analizi: Gerçek dünya uygulamalarında karşılaşılabilecek çeşitli senaryoları değerlendirerek hangi veri yapısının daha iyi performans göstereceğini belirler.</li><li>Uygulama Gereksinimleri: Uygulamanın gereksinimlerini anlamak, veri yapısının seçiminde kritik bir faktördür. Örneğin sıkça ekleme silme işlemleri gerektiren bir uygulama için bağlı liste daha uygun olabilir.</li><li>Kullanım Kolaylığı ve Bakımı: Veri yapısının ne kadar kolay kullanılabileceği, öğrenilmesi ve bakımının ne kadar zahmetli olduğu gibi faktörler de göz önünde bulundurulmalıdır.</li></ul><p>Bir veri yapısı seçimi kısaca şu şekilde özetlenebilir:</p><ol><li>Desteklenmesi gereken temel işlemlerin belirlenmesi (ekleme, çıkarma, arama vb.) için sorunun analiz edilmesi.</li><li>Kaynak kısıtlamalarının ölçülmesi ve gerekli analizlerin yapılması.</li><li>Gereksinimleri karşılayan en iyi veri yapısının seçilmesi.</li></ol><p>Soyut veri tipleri (abstract data type), belirli bir veri yapısının nasıl görüneceğini ve hangi işlemlerin yapılabileceğini uygulama detaylarından bağımsız, soyut olarak tanımlayan kavramdır. Yapılacak işlemlerin nasıl gerçekleştirileceği soyut veri tiplerinin konusu değil veri yapılarının konusudur. Soyut veri tipleri, veri yapıları üstünde bir katman olarak durur. Yani, soyut veri tipi bir konsepttir, veri yapısı ise bu konseptin somut bir uygulamasıdır.</p><p>Yazılım geliştirme sürecini daha verimli, esnek ve sürdürülebilir hale getirmesi ve yazılım sistemlerinin yapısını, davranışını ve etkileşimini organize etme konusunda yardımcı olması için tasarım desenleri kullanılır.</p><p>Tasarım desenleri genellikle 3 ana kategoriye ayrılır:</p><ul><li>Yaratıcı desenler (creational patterns): Nesne yaratım sürecini kontrol eder. Bunlar; singleton deseni, factory method deseni, builder deseni, abstract factory deseni ve prototype desenidir.</li><li>Yapısal desenler (structural patterns): Sınıflar ve nesneler arasındaki ilişkileri düzenler. Bunlar; adapter deseni, composite deseni, decorator deseni, facade deseni, flyweight deseni, proxy deseni, bridge desenidir.</li><li>Davranışsal desenler (behavioral patterns): Nesnelerin birbirleriyle olan etkileşimlerini ve iletişimlerini tanımlar. Bunlar; observer deseni, strategy deseni, command deseni, iterator deseni, mediator deseni, chain of responsibility deseni, state deseni, template method deseni, visitor deseni, interpreter deseni, memento desenidir.</li></ul><p>Tasarım desenleri;</p><ul><li>Tekrarlanabilir özelliği sayesinde daha önce çözülmüş problemleri kapsayarak geliştiricilerin zaman kazanmasını sağlaması</li><li>Geliştiriciler arasında ortak bir dil oluşturarak karmaşık sistemlerin anlaşılmasını kolaylaştırması</li><li>Sistemlerin değişen gereksinimlerine uyum sağlamasını kolaylaştırması</li><li>Kodun daha düzenli ve anlaşılır olmasını sağlayarak bakım süreçlerini kolaylaştırması</li></ul><p>özellikleri bakımından yazılım geliştirmede önem arz eder.</p><p>Bir bilgisayar programı veya uygulamalar belirli problemler üzerine geliştirilirler. Problem, kullanıcı ihtiyaçlarını veya belirli işlevleri karşılamak için çözülmesi gereken meseledir. Bir problemin tanımı, problemin nasıl çözüleceğine dair bir kısıtlama içermemelidir ancak kabul edilebilir bir çözüm yöntemine dair kaynaklar üzerinde kısıtlamalar içerebilir.</p><p>Bir problemi çözmek için izlenecek yol veya süreç, algoritma olarak tanımlanır. Algoritmalar, belirli bir girdiyi alır, bu girdiyi işler ve bir çıktı üretir. Bir problemin birden fazla algoritma ile çözülmesi mümkündür ve belirli bir algoritma yalnızca bir sorunu çözer. Algoritmaların bazı temel özellikleri vardır:</p><ul><li>0 veya daha fazla girdi alır ve her girişi doğru çıktıya dönüştürerek bir çıktı üretir veya istenen işlevi hesaplar.</li><li>Bir dizi somut adımdan oluşur ve her adım kesin bir şekilde tanımlanır.</li><li>Sonlu olmalıdır.</li></ul><p>Bir program, algoritmanın bir örneği veya somut temsilidir. Bir probleme çözüm getirmeyi veya işlevselliği arttırmayı amaçlarlar. Kısaca, problem çözülmesi gereken bir durum; algoritma, bir problemi çözmek için izlenecek adımların tanımı; program, algoritmanın belirli bir programlama dilinde yazılmış ve bilgisayar tarafından çalıştırılabilir bir forma dönüştürülmüş versiyonudur denilebilir.</p><p>Bilgisayardaki her işlemin bir program tarafından yürütüldüğünü ve algoritmaların sonlu olması gerektiğini söylemiştik. İşletim sistemi bir bilgisayar programı olmasına rağmen algoritmanın teknik tanımını karşılamamaktadır. İşletim sistemleri böyle bir programdır.</p>"
  },
  "python-ile-qr-kod-olusturmak": {
    "title": "PYTHON İLE QR KOD OLUŞTURMAK",
    "summary": "QR kod (Quick response) veya karekod (data matrix) makinelerle okutulabilen bir matris barkod (iki boyutlu barkod) türüdür.",
    "content": "<p>QR kod (Quick response) veya karekod (data matrix) makinelerle okutulabilen bir matris barkod (iki boyutlu barkod) türüdür. 1994 yılında geliştirilen Japon DENSO firmasına patentlidir.</p><p>QR kodlarının veri kapasitesi oldukça sınırlıdır:</p><ol><li>Nümerik veriler için en fazla 7090 karakter,</li><li>Alfanümerik verileri için en fazla 4291 karakter,</li><li>İkili sistem için (8 bit) olarak en fazla 2953 byte,</li><li>Kanji/Kana olarak en fazla 1817 karakterdir.</li></ol><p>Günümüzde dijital kameralı mobil telefonların etkisiyle QR kodu kullanımı yaygınlaşmaya başlamıştır. QR kodu çözümlendiğinde kullanıcıyı internet adresine, e-posta adresine, telefon numarasına, iletişim bilgilerine, SMS veya MMS’ye veya coğrafi konum bilgisine yönlendirebilir.</p><p>İnternette birçok kaynaktan ücretsiz QR kod dönüştürücüsü edinilebilir. Bunun yanı sıra, zamandan veya maliyetten tasarruf etmek yahut QR kod özelleştirilmek istenildiğinde bu kaynaklardan daha fazlasına ihtiyaç duyulabilir. Bu yazımda Python ile çeşitli formlardaki verilerin QR koda nasıl dönüştürüleceğini anlatacağım. Bunun için segno modülünden yararlanacağız.</p><p>Segno modülü ile bir metni ve linki QR koda dönüştürülebilir yahut daha az veri barındırabilen mikro QR kodları oluşturulabilir. Bunlara ek olarak wifi bağlantısı kurmak, VCard veya Mecard oluşturmak, e-posta göndermek, coğrafi konumunuzu göstermek veya avrupa ödeme sistemlerinden biri olan EPC için QR kod oluşturmak gibi işlemler de bu modül sayesinde gerçekleştirilebilir. Bu modül ile yerel bir cihazda bulunan dosya veya resim QR koda dönüştürülemez çünkü QR kodları çok az veri depolamaya izin verdiği için içinde bir resmi veya dosyayı barındırabilecek yapıda değildir. Ancak bir sunucuda depolanan resim veya dosyanın linkini QR koda çevirmek mümkündür.</p><p>Öncelikle Segno modülünü bilgisayarımıza yüklemek için terminali açarak aşağıdaki komutu çalıştıralım.</p><pre><code>pip install segno</code></pre><p>Ardından bu modülü uygulama içine import edelim. Segno modülü ile metin ve linkleri QR koda dönüştürecek ve mikro QR kod oluşturacağız. Segno modülünün içinde bulunan helpers modülüyle ise wifi, vcard, coğrafi konum ve email için QR kodları oluşturacağız.</p><pre><code>import segno\nfrom segno import helpers</code></pre><p>Bir metin verisini veya linki “make_qr” fonksiyonuyla QR koda dönüştürebilir ve “save” özelliğiyle oluşturulan QR kodu yerel cihazımıza kaydedebiliriz.</p><pre><code>text = \"Hello World!\"\nlink = \"www.linkedin.com/in/hanifekaptan-u1f90d\"\ntextqr = segno.make_qr(text)\nlinkqr = segno.make_qr(link)\ntextqr.save(\"textqr.png\", scale=15)\nlinkqr.save(\"linkqr.png\", scale=15)</code></pre><p>QR kod oluştururken dikkat edilmesi gereken şey, verinin büyüklüğüdür. Verinin büyüklüğü QR kodun okunabilirliğini kullanılan cihaza göre etkileyebilir. Benzer şekilde mikro QR kodları zaman zaman, normal telefon kameralarıyla okunmayabilir. Bunun için gerekli donanıma sahip olunduğunda mikro QR kodlar kullanışlı olabilir.</p><pre><code>content = \"it's a micro qrcode\"\nmikroqr = segno.make_micro(content)</code></pre><p>Bir wifi için QR kod oluşturmak için “make_wifi” fonksiyonu kullanılır. make_wifi fonksiyonu parametre olarak ssid, şifre ve güvenlik parametrelerini alır. Security(güvenlik) parametresi 3 değer alabilir: “WPA”, “WEP” veya None.</p><pre><code>ssid = \"ssid value\"\npassword = \"sample password\"\nsecurity = \"WPA\" #It can be WPA or WEP\nhelpers.make_wifi(ssid, password, security)</code></pre><p>VCard veya MeCard için QR kod oluşturmak, diğerlerinden biraz daha zahmetli olabilir. VCard için “make_vcard”, MeCard için “make_mecard” fonksiyonu kullanılır. Temelde diğerleriyle aynı mantıkla çalışan bu fonksiyonlar diğerlerinden daha fazla parametre alır ancak hangi parametreleri kullanılıp kullanılmayacağı tamamen kullanıcıya kalmıştır. Aşağıda bulunan değerlerden bir veya daha fazlası ilgili fonksiyonda kullanılabilir.</p><pre><code>name= \"name\"\ndisplayname= \"displayname\"\n...\nhelpers.make_vcard(name= name,\n                   displayname= displayname,\n                   ...)\nhelpers.make_mecard(name= name,\n                   displayname= displayname,\n                   ...)</code></pre><p>E-mail göndermek için bir QR kod oluşturduğumuzda “make_email” fonksiyonu kullanılır ve temel olarak, kime gönderileceğini içeren to, başlık değerini içeren subject ve mail içeriğini oluşturan body parametreleri kullanılır. Buna ek olarak cc veya bcc değerleri de isteğe göre kullanılabilir veya kullanılmayabilir.</p><pre><code>to = \"sampleemail@gmail.com\"\nsubject = \"sample email qrcode\"\nbody = \"hello world\"\nhelpers.make_email(to, subject= subject, body= body)</code></pre><p>Coğrafi konum bilgisini QR koda dönüştürürken “make_geo” fonksiyonu kullanılır ve bu fonksiyon 2 sayısal parametre alır. Bunlar enlem (latitude) ve boylam (longtitude) parametreleridir. Belli bir aralıkta değer alan enlem ve boylam değerlerine, mevcut olmayan değer girildiğinde hata verecektir.</p><pre><code>latitude = 39.55\nlongtitude = 32.50\nhelpers.make_geo(lat= latitude, lng= longtitude)</code></pre><p>Python kullanarak verileri QR koda dönüştürmek Segno ile bu kadar kolaydır.</p><h3>Kaynakça:</h3><ol><li>https://tr.m.wikipedia.org/wiki/QR kodu</li><li>https://tr.m.wikipedia.org/wiki/Karekod</li><li>https://segno.readthedocs.io/en/latest/</li><li>https://pypi.org/project/segno/</li></ol>"
  },
  "veri-yapilari-stack": {
    "title": "VERİ YAPILARI VE ALGORİTMALAR: STACK VERİ YAPISI",
    "summary": "Veri yapısı verileri organize etme, saklama, işleme yöntemlerini tanımlayan çeşitli veri gösterimleridir.",
    "content": "<p>Veri yapısı verileri organize etme, saklama, işleme yöntemlerini tanımlayan çeşitli veri gösterimleridir. Bundan yola çıkarak verilerin etkin bir şekilde yönetilmesi için uygun veri yapılarının seçilmesi ve kullanılması gerektiği söylenebilir.</p><p>Bilgisayar bilimlerinde kullanılan en temel veri yapılarından biri, stack (yığın) veri yapısıdır. Stack veri yapısı tıpkı adından anlaşıldığı gibi bir yığın olarak düşünülebilir. Bu veri yapısının en önemli özelliği LIFO (Last In, First Out) yani “son giren ilk çıkar” prensibiyle çalışmasıdır.</p><p>Kolay anlaşılabilmesi için üst üste yığılmış bir miktar tabak olduğunu hayal edelim. Bu tabak yığınından ihtiyacımız doğrultusunda bir tabak alabilir ve işimiz bittikten sonra tabağı yerine koyabiliriz. Peki bu yığından, tabağı nereden almayı tercih ettik ve koyduğumuz tabağı bu yığında nereye koyduk? Tabağı, tabak yığının en üstünden alıp yine en üstüne koymak elbette hemen herkesin tercih edeceği bir davranıştır. Örnekte görüldüğü gibi yığın üzerinde gerçekleştirilen işlemler, yığının en üst kısmındaki ögeyle gerçekleştirilir. Bu, stack (yığın) veri yapısının mantığını anlatan temsili bir örnektir ve bu örnek stack veri yapısının, verileri nasıl organize ettiğini, verilerin nasıl saklandığını ve veriler üzerinde nasıl işlemler gerçekleştirilebileceğini açıklar. Örneğe göre; tabakların her biri bir veriyi, üst üste konulmuş tabaklar bütünü de bir diziyi temsil eder ve bunlar bilgisayarın ilgili memory bölgelerinde saklanır.</p><h2>Stack veri yapısındaki temel işlemler şunlardır:</h2><ul><li>Push: Yığına eleman eklemeyi sağlar. Yeni eleman, yığının en üstüne eklenir. Eğer yığın doluysa ekleme işlemi gerçekleştirilmez ve program hata döndürür.</li><li>Pop: Yığından eleman çıkarmayı sağlar. Yığından çıkarılmak istenen eleman, yığının en üstündeki elemandır. Eğer yığın boşsa eleman çıkarma işlemi de yapılamaz ve program hata döndürür.</li><li>Peek/Top: Yığının en üstteki elemanını verir.</li><li>getCount: Yığının içerdiği eleman sayısını verir.</li><li>isEmpty: Yığının boş olup olmadığını verir.</li><li>isFull: Yığının dolu olup olmadığını verir.</li></ul><h2>Stack veri yapısının temel mantığını anladıysak nerelerde kullanıldığına göz atalım:</h2><ul><li>Programlama dillerinde kullandığımız fonksiyon yapıları stack veri yapısından yararlanır. Fonksiyon çağrıldığında, her çağrının yerel değişkenleri ve geri dönüş adresleri stack’te saklanır ve fonksiyon sona erdiğinde stack’ten çıkarılır.</li><li>Birçok uygulamada gördüğümüz, basitçe Ctrl+Z ile gerçekleştirdiğimiz, undo (geri alma) işlemi de stack veri yapısı ile yapılır. Kullanıcının yaptığı her işlem stack’e eklenir ve geri alma işlemiyle, yapılan son işlem yani stack’e eklenen son veri, çıkarılarak geri alma işlemi gerçekleştirilir.</li><li>Derleyicilerin, kaynak kod işlemesinde birçok noktada stack kullanımına rastlarız. Sözdizimsel analiz aşamasında dilin kurallarını kontrol etmek, bir hata meydana geldiğinde programın hangi fonksiyonları çağırdığını göstermek, derleyicinin kaynak kodu parçalara ayırırken (tokenization) her bir token’ı stack’e ekleyip işleme alması, döngü yapılarının kontrolü bunlardan sadece birkaçıdır.</li><li>Oyunlarda, karakterin veya nesnelerin durumlarını yönetmek için stack kullanılabilir. Bir karakterin hareketi veya envanter eylemleri stack üzerinde saklanabilir.</li><li>Zaman zaman stack veri yapısı, diğer veri yapıları veya algoritmalar ile birlikte de kullanılabilir.</li></ul><p>Stack veri yapısının avantajlarından şu şekilde bahsedebiliriz;</p><ul><li>Stack veri yapısı, O(1) zaman karmaşıklığına sahiptir ve özellikle yüksek performans gerektiren durumlar için ideal bir seçenektir.</li><li>Anlaşılması ve uygulanması basit olması sebebiyle geliştiricilerin uygulamaları daha hızlı bir şekilde geliştirmesine olanak tanır.</li><li>Boyut genellikle sadece gerekli olduğu kadar yer kapladığı için hafıza kullanımı açısından verimlidir. Ayrıca bu özelliği, stack veri yapısının hafif ve düşük maliyetli olduğuna da işaret eder.</li></ul><p>Buna karşın dezavantajlı yanları da vardır;</p><ul><li>Boyut, dinamik olmadığı için stack dolduğunda (stack overflow) eleman ekleme mümkün olmaz. Özellikle büyük veri setlerinde, istenmeyen sorunlara sebep olabilir.</li><li>Stack, yalnızca en üstteki elemana erişime izin verir. Bu, belirli bir elemana doğrudan erişimi zorlaştırır.</li><li>Büyük veri setleriyle çalışırken stack üzerinde yapılan işlemler yavaşlayabilir. Özellikle çok sayıda fonksiyon çağrısı veya derinlemesine döngü yapıları varsa performans sorunları ortaya çıkabilir.</li></ul><p>Stack veri yapısından, özelliklerinden, avantaj/dezavantajlarından ve kullanım alanlarından bahsettik. Son olarak stack veri yapısını Java kullanarak uygulayalım.</p><p>Not: Bu örnekte yazılan bütün kodlar, 24 Eylül 2024 itibariyle Java’nın son sürümü olan Java 22 kullanılarak ve NetBeans üzerinden yazılmaktadır.</p><p>Eğer ilk kez NetBeans kullanılyorsanız, açıldığında muhtemelen ekrana boş bir sayfa gelecektir. Kodlarımızı yazmak için öncelikle bir java dosyası açmamız gerekir. Bunun için öncelikle ekranın sol üst kenarında bulunan File seçeneğini açtıktan sonra New Project seçeneğini seçelim. Açılan sekmede sırasıyla Java With Ant ve altında bulunan Java Application’ı seçelim ve Next düğmesine tıklayalım. Ardından açılan sonraki sayfada uygulamanın adını “MyStack” olarak dolduralım ve konumunu belirleyelim. Daha sonra Finish butonuna bastığımızda DataStructure klasörü altında “MyStack.java” adında java dosyası oluşturulacaktır.</p><pre><code>package DataStructures;\n\npublic class MyStack { \n    public static void main(String[] args) {\n        System.out.println( \"Veri Yapıları: Stack\" ); \n    } \n}</code></pre><p>Dosya oluşturulduğunda, bazı kodlar hazır bir şablon şeklinde açılacaktır. İlk satırda bulunan “package DataStructure” ifadesi, dosyanın bulunduğu klasörü ifade eder. MyStack class’ı ile kendi Stack yapımızı oluşturacak ve içerisine temel işlemleri ekleyeceğiz. Burada dikkat etmemiz gereken husus, dosyanın ismi ile class’ın adının aynı olmasıdır. Aynı olmaması durumunda uygulama hata verecektir. Eğer dosyanızı “stack” adıyla oluşturduysanız, uygulama kullanım esnasında hata verebilir. Bunun sebebi Java’nın kendi stack sınıfının olması ve sizin yeniden stack adıyla bir dosya oluşturmanızla birlikte karmaşıklıkların oluşabilmesinden kaynaklanabilmektedir. Sınıf parantezlerinin arasında hazır olarak gelen “public static void main(String[] args)” fonksiyonu, uygulamada çalıştırmak istediğimiz kodları yazacağımız kısımdır. Blokları arasına “System.out.println( “Veri Yapıları: Stack” );” yazarak ekrana kendi başlığımızı yazdırmış oluyoruz.</p><p>...</p>"
  },
  "elektronik-devreler-kirchhoff-kanunlari": {
    "title": "ELEKTRONİK DEVRELER: KIRCHHOFF KANUNLARI VE ÇEVRE DENKLEMİ YÖNTEMİ",
    "summary": "Elektronik devrelerde akım ve voltaj, devrenin işleyişini belirleyen temel fiziksel büyüklüklerdir.",
    "content": "<p>Elektronik devrelerde akım ve voltaj, devrenin işleyişini belirleyen temel fiziksel büyüklüklerdir. Akım elektrik yüklerinin hareketini voltaj ise bu hareketin nedenini ve yönünü belirler.</p><p>Her ikisi de elektrik enerjisinin iletimini ve kullanımını etkiler. Ayrıca elektrik devrelerinin temel yapı taşlarını oluşturan akım ve voltaj kavramlarının devre analizi, tasarımı ve işleyişinde kritik öneme sahip olduğu söylenebilir. Kısaca bu kavramlara göz atalım.</p><p>Akım, bir noktadan diğerine geçen elektrik yüklerinin (genellikle elektronların) akış hızını ifade eder. I sembolüyle gösterilir ve Amper (A) birimiyle ölçülür. Genellikle akım, pozitif yüklerin hareketi olarak düşünüldüğü için akım yönü pozitif yüklerin yönü olarak tanımlanır. Ancak gerçekte, akım genellikle negatif yükler (elektronlar) tarafından taşınır. Akım, devre elemanları (dirençler, kapasitörler vb.) üzerinde voltaj düşümleri oluşturur ve elektrik enerjisinin taşıyıcısıdır. Cihazların çalışması için gereken enerjiyi sağlar.</p><p>Voltaj, iki nokta arasındaki elektrik potansiyeli farkıdır. U veya V sembolü ile gösterilir ve Volt (V) birimiyle ölçülür. Voltaj, yüklerin bir noktadan diğerine hareket edebilmesi için gereken itici güçtür. Yüksek potansiyelli bir noktadan düşük potansiyelli bir noktaya doğru bir akım oluşturacak şekilde tanımlanır. Voltajın devredeki rolü, devredeki akımı oluşturması (ki voltaj olmadan akım akmaz) ve devre elemanları üzerindeki iş yapma kapasitesini belirlemesidir. Bir direnç üzerindeki voltajın o direnç üzerinden geçen akımı etkilemesi buna örnek olarak gösterilebilir.</p><h2>Ohm Yasası</h2><p>Akım ve voltaj arasındaki ilişki ohm yasası ile açıklanabilir. Ohm yasası, bir iletkenin uçları arasındaki voltajın, iletkenin üzerinden geçen akım ile orantılı olduğunu belirtir. Yani, bir devredeki akım, o devredeki voltaja ve direnç değerine bağlıdır. Matematiksel olarak şu şekilde gösterilir:</p><p>U = I x R</p><p>Bu formülde U gerilimi, I elektrik akımını ve R direnci ifade eder. Görsel üzerinden ohm yasasını örneklendirelim. Resmin solunda seri bağlı ve sağında paralel bağlı bir elektrik devresi görüyoruz. Bu devrelerde bir gerilim kaynağı ve iç direnci 1 ohm olan 2 ampul var ancak devreden geçen akım bilinmiyor. Ohm yasasını kullanarak, devrelerden ne kadarlık akım geçtiğini bulalım:</p><p>Öncelikle soldaki örnekten başlayalım. Devrede 6 volt’luk bir gerilim olduğunu biliyoruz. Elektrik devrelerinde seri bağlı dirençlerin değeri, değerleri toplanarak hesaplanır. Bu devrede de seri bağlı ampullerin iç dirençlerini hesaplamak için bu yöntemi kullanacağız. İç direnci 1 ohm olan 2 seri bağlı ampul 2 ohm’luk iç dirence sahiptir. Öyleyse akımı hesaplamak için formülden faydalanabiliriz. “6 V = I x 2 ohm” Bu şekilde I akım değeri 3 amper olarak hesaplanır. Yani devreden geçen akım, 3 amperdir.</p><p>İkinci olarak sağdaki örneğe bakalım. Devrede 6 volt’luk bir gerilim kaynağı ve birbirine paralel bağlanmış iç dirençleri 1 ohm olan 2 ampul var. Paralel bağlı dirençlerde R eşdeğer hesaplanması gerekir. İki paralel direnç için eşdeğer direnç Reş şu şekilde hesaplanır: “1/Reş = 1/R1 + 1/R2” Bu formülde R1 ve R2 direnç değerlerinin yerine, ampullerin iç direncini ifade eden 1 ohm değerlerini yazmamız gerekiyor 1/1 + 1/1 = 2 değerini verir. 1/Reş = 2 ise Reş = 1/2 veya 0.5 ohm’dur diyebiliriz. Öyleyse elimizde 6 volt’luk bir gerilim ve eş değer direnci 0.5 ohm olan dirençlerimiz var. Formülü uygulayacak olursak, “6 V = I x 0.5 ohm” olur. I akım değeri böylece 12 amper olarak elde edilir.</p><h2>KIRCHOFF KANUNLARI:</h2><p>Akım ve voltaj ilişkilerini açıklamayı amaçlayan başka bir fizik yasası ise Kirchhoff kanunlarıdır. Kirchhoff kanunları elektronik devrelerde akım ve voltaj ilişkilerini tanımlayan iki temel ilkeyi açıklar. Bunlar, Kirchhoff’un akım yasası (KCL- Kirchhoff’s Current Law) ve Kirchhoff’un voltaj yasasıdır (KVL- Kirchhoff’s Voltage Law). Bu kanunlar, direnç, kapasitör, bobin ve diğer bileşenlerle birlikte kullanılarak karmaşık devrelerin çözümünde de yardımcı olur.</p><h3>Kirchhoff’un Akım Yasası (KCL)</h3><p>Kirchhoff’un akım yasası, bir düğüm noktasındaki toplam akımın sıfır olduğunu söyler. Yani, bir düğüm noktasına giren akımların toplamı, o düğüm noktasından çıkan akımların toplamına eşittir. Bu yasa, elektrik akımının korunumu ilkesine dayanır. Bu matematiksel olarak şu şekilde ifade edilebilir:</p><p>∑ Igiren =∑ Içıkan</p><p>Görselde görüldüğü üzere bir düğüm noktasına I1 ve I4 akımları girerken bu noktadan I2, I5 ve I3 akımları çıkıyor. Kirchhoff’un akım yasası, bu akımlar hakkında, giren akım değerleri toplamının çıkan akım değerleri toplamına eşit olduğunu söyler. Bunu, şu şekilde gösterebiliriz:</p><p>I1 + I4 = I2 + I5 + I3</p><h3>Kirchhoff’un Voltaj Yasası (KVL)</h3><p>Kirchhoff’un voltaj yasası, bir kapalı devredeki toplam voltajın sıfır olduğunu söyler. Yani, bir devre döngüsündeki tüm voltajların (hem pozitif hem de negatif) toplamı sıfırdır. Bu yasa, enerji korunumu ilkesine dayanır. Bu matematiksel olarak şu şekilde ifade edilebilir:</p><p>∑ U = 0</p><p>Görseldeki devrede Kirchhoff’un voltaj yasasını uygulamak istersek bunu şu şekilde yazarız:</p><p>-E1 + V1 + V2 = 0</p><p>Veya devreden geçen akım I dersek R1 ve R2 dirençleri üzerinde oluşan V1 ve V2 gerilimleri şöyle ifade edebiliriz:</p><p>-E1 + (I x R1) + (I x R2) = 0</p><p>Çevre denklemi yönteminden bahsederken Kirchhoff’un voltaj yasasına yeniden değinecek ve neden E1 değerinin eksi, V1 ve V2 değerlerinin artı olarak yazıldığından, görseldeki saat yönündeki ok çiziminde bahsedilecektir.</p><h2>ÇEVRE DENKLEMİ YÖNTEMİ</h2><p>Elektrik devre analizinde Kirchhoff yasalarının bir uygulayıcısı olarak çevre denklemi yöntemi kullanılabilir. Bu yöntem, devredeki akım ve voltajların belirlenmesinde, basit veya karmaşık devrelerde sistematik bir yaklaşım sunar. Ayrıca çevre denklemi yöntemi hem AC devre analizine hem de DC devre analizine uygundur. Çevre denklemi yönteminin adım adım nasıl uygulandığına bakalım:</p><h3>Devreyi Tanımlamak:</h3><p>Devreyi ve elemanları (dirençler, kapasitörler, bobinler, kaynaklar vb.) belirleyin. Çevre yöntemini uygulayabilmek için devreyi net bir şekilde anlamak önemlidir. Görseldeki devreye baktığımızda devrede 9 V değerinde bir gerilim kaynağı ve büyüklüğü bilinmeyen 2 direnç olduğunu görüyoruz. Ayrıca devreden 1.8 A büyüklüğünde bir akım geçtiği ve dirençlerin üzerindeki gerilim düşümü de verilmiş. Öyleyse çevre denklemini kullanarak bilinmeyen direnç değerlerini hesaplayalım.</p><h3>Çevreleri Belirlemek:</h3><p>Devredeki çevreleri belirleyin. Çevre, herhangi bir yöne (saat yönüne veya tersi yöne doğru) seçilebilir. Çevre belirlemede dikkat edilmesi gereken kurallar vardır. Çevre en az bir elemanın üzerinden geçmelidir ve seçilen çevreye veya çevrelere göre devrede üzerinden çevrenin geçmediği eleman olmamalıdır. Çevre akımın yönünü belirlemek için bir referans olarak kullanılır. Örnekte çevre yönünün saat yönünde çizildiğini görüyoruz. Buna göre akımın girdiği yer artı (+) çıktığı yer eksi (-) olarak işaretlenir. Eğer saat yönü ters yönde seçilseydi dirençler üzerindeki artı ve eksi işaretlemeleri çevre yönüne göre belirlerdik çünkü çevre yönü devrede akımın yönünü gösterir. Çevre yönünün sonucu değiştirmediğini ancak sonucun işaretini değiştirdiğini biliyoruz. Böylece görseldeki dirençlere işaretlenen artı ve eksilerin nereden geldiği anlaşılabilir. Aksi belirtilmedikçe devre analizinde artı ve eksi uygulamaları çevre yönüne göre belirlenir.</p><h3>Kirchhoff’un Voltaj Yasasını (KVL) Uygulamak:</h3><p>Çevre üzerinde Kirchhoff’un voltaj yasası uygulanır. KVL, bir çevredeki toplam gerilimin sıfır olduğunu ifade eder. Bu aşamada, voltaj düşümleri ve kaynaklar dikkate alınarak denklemler oluşturulur. Örneğe bakarak çevre denklemini yazalım:</p><p>-V1 + V2 + V3 = 0</p><p>Çevre yönüne göre akım, V1 gerilim kaynağının eksi ucundan girdiği için V1 gerilimi başına eksi değeri alarak yazılır. Ancak diğer gerilimlere baktığımız zaman çevre yönü artı ucundan girmiştir. Denklemin doğru olup olmadığını görmek için soruda verilen değerleri denklemde yerine yazalım:</p><p>-9V + 3.6V + 5.4V = 0</p><p>Denklemin doğru olduğunu basit bir hesaplamayla görüyoruz.</p><h3>Kirchhoff’un Akım Yasasını (KCL) Uygulamak:</h3><p>Çevre üzerindeki akımlar için Kirchhoff’un akım yasası uygulanır. Her direncin üzerinde giren ve çıkan akımlar denklemde yazılır. Daha karmaşık devrelerde birden fazla çevre yönü çizmemiz gerekecek. Ancak örneğimizde bir tane çevre çizildiği ve dirençlerin üzerinden geçen akımların toplamı çevreden geçen akıma eşittir. Ohm kanunundan ve KCL’den faydalanarak bu denklemi yeniden yazalım. Soruda V2 gerilimine sahip direncin 2R ve V3 gerilimine sahip direncin 3R olarak verilmiş olduğunu düşünelim. Öyleyse:</p><p>-9V + (1.8A x 2R) + (1.8A x 3R) = 0</p><h3>Denklemi Çözmek:</h3><p>Oluşturulan denklemler sistematik bir şekilde çözülerek akım, voltaj veya direnç değerleri bulunur. Denklemi çözelim:</p><p>-9V + 3.6R + 5.4R = -9V + 9R = 0</p><p>9R = 9V ve R = 1 ohm olur. İşlemlere göre dirençler de sırasıyla 2 ohm ve 3 ohm değerindedirler.</p><p>Bu yazıda ele alınan konu Kirchhoff yasalarını ve çevre denklemi yönteminin temellerini anlatmaktadır. Daha karmaşık ve çok düğümlü devre sistemlerinde çevre denklemi yöntemi “mesh analizi” başlığı altında anlatılacaktır.</p>"
  },
  "elektronik-devreler-thevenin-teoremi": {
    "title": "ELEKTRONİK DEVRELER: THEVENİN TEOREMİ",
    "summary": "Thevenin Teoremi, elektrik devrelerinin analizi için kullanılan son derece yararlı bir yöntemdir.",
    "content": "<p>Thevenin Teoremi, elektrik devrelerinin analizi için kullanılan son derece yararlı bir yöntemdir. Bu teorem, herhangi bir lineer elektrik devresini, bir voltaj kaynağı (Vth) ve bir dirençle (Rth) temsil edilebilecek basit bir devreye dönüştürmeyi sağlar. Thevenin Teoremi, özellikle karmaşık devrelerin basitleştirilmesi ve belirli bir yük üzerindeki etkilerin analiz edilmesi için kullanılır. Bir devreyi temsil etmek için gereken Thevenin eşdeğer devresi şu şekilde tanımlanır:</p><p><strong>Thevenin Eşdeğer Voltajı (Vth):</strong> Thevenin eşdeğer voltajı, bir devrenin herhangi iki terminali arasındaki voltajdır. Bu voltaj, devredeki diğer kaynaklar ve dirençler dikkate alınarak hesaplanır. Bir elektrik devresinde yük, direnç, bobin, kondansatör gibi belirli bir iş yapan, enerji tüketen veya depolayan elemanlardır ve eşdeğer voltaj hesaplanmak istenirse, devredeki yükler kaldırılarak hesaplama yapılır.</p><p><strong>Thevenin Eşdeğer Direnci (Rth):</strong> Eşdeğer direnç, tüm bağımsız devre kaynakları kapatıldığında (voltaj kaynakları kısa devre, akım kaynakları açık devre yapılır) belirlenen iki terminal arasındaki direnç değeridir.</p><h2>Thevenin teoremini uygulamak için aşağıdaki adımlar takip edilir:</h2><h3>Devreyi Tanımlama:</h3><p>Thevenin teoremi uygulanacak devre belirlenir. Genellikle Thevenin teoremi uygulanacak kısım A ve B uçları arasında açık devre şeklinde gösterilir. Ancak bu, devrede analiz yapılmak istenilen kısmın bir gösterimidir ve devrenin normalde açık devre olmadığı bilinir.</p><h3>Eşdeğer Voltajı Hesaplama (Vth​):</h3><p>Vth değerini hesaplamak için Kirchhoff’un gerilim yasasından faydalanabiliriz. Devredeki toplam gerilim 0’a eşit olmalıdır. Öyleyse A ve B uçları arasında, direnç (veya diğer yükleri) kaldırarak gerilimi hesaplarız.</p><h3>Eşdeğer Direnci Hesaplama (Rth​):</h3><p>Tüm bağımsız kaynaklar devreden kaldırılır:</p><ul><li>Voltaj kaynakları kısa devre yapılır.</li><li>Akım kaynakları açık devre yapılır.</li></ul><p>Bu işlem gerçekleştirildiğinde, birbirine seri veya paralel olarak bağlanmış dirençleri içeren bir devre elde edilir. İki uç arasındaki direnci hesaplayarak Rth ​değeri elde edilir.</p><h3>Yeni Devreyi Çizme:</h3><p>Hesaplanan Rth ve Vth değerleriyle devrenin Thevenin eşdeğer modeli çizilir ve gerekliyse devreyi tamamlanır.</p><h2>Örnek:</h2><p>Yukarıdaki devrede A ve B uçları arasında Thevenin eşdeğerini bularak 5 Ω ve 1 Ω’luk dirençlerden geçen akımı hesaplayalım.</p><p>Devrede 10 V ve 16 V değerlerinde iki gerilim kaynağı ve 4 Ω, 2 Ω, 5 Ω ve 1 Ω değerlerinde dirençler olduğunu görüyoruz. Soruda A ve B uçları arasındaki thevenin eşdeğerini istediği için devrenin, gerilim kaynaklarını ve 4 Ω ile 2 Ω dirençlerini içeren kısmı üzerinden hesaplamalar yapacağız.</p><p>Devreyi tanımladığımıza göre Vth değerini hesaplayalım. A ve B uçları arasındaki dirençleri kaldırdığımızda gerilim değerini şu şekilde hesaplarız:</p><p>-10 V + 16 V = 6 V</p><p>Gerilim kaynakları birbirine ters yönde bağlandıkları için ok yönünde gerilim değerlerini topladığımızı söyleyelim. Aynı yönlü gerilim kaynaklarını doğrudan da toplayabiliriz. Böylece Vth değeri 6 V olarak hesaplanır.</p><p>Sonraki adım olarak Rth​ değerini hesaplarız. A ve B uçları arasındaki bağımsız gerilim kaynakları kısa devre bağımsız akım kaynakları ise açık devre yapılır. Bu örnek akım kaynağı içermediği için gerilim kaynaklarını kısa devre yapalım. Devrenin A ve B uçları arasında birbirine seri bağlanmış 2 Ω ve 4 Ω’luk dirençler kalır. Rth​ değeri bu soruda seri bağlı dirençlerin toplanması şeklindedir. Böylece Rth değeri 6 Ω olarak hesaplanır.</p><p>Son olarak hesapladığımız Rth​ = 6 Ω ve Vth = 6 V değerleriyle devrenin Thevenin eşdeğer modelini çizelim ve devreyi tamamlayalım. Soruda Thevenin eşdeğerini bulmamız ve 5 Ω ve 1 Ω’luk dirençlerden geçen akımı hesaplamamız isteniyordu. Thevenin eş değer modelini ve Ohm yasasını kullanarak 5 Ω ve 1 Ω’luk dirençlerden geçen akımı hesaplayalım.</p><p>6 V = I x (Rth + 5 Ω + 1 Ω) = I x (6 Ω + 5 Ω + 1 Ω) = I x 12 Ω</p><p>I = 6 V / 12 Ω = 0.5 A olarak hesaplanır.</p><p>Devrede 5 Ω ve 1 Ω’luk dirençlerin üzerinden geçen akımı bir önceki yazımda anlattığım çevre denklemi yöntemiyle de çözmek mümkündür. Çevre denklemi yöntemi hakkında daha fazla bilgi almak için daha önce yazdığım yazıya göz atabilirsiniz.</p>"
  },
  "veritabani-yonetim-sistemleri-giris": {
    "title": "VERİTABANI YÖNETİM SİSTEMLERİ: GİRİŞ",
    "summary": "Tarihin çeşitli dönemlerinde çeşitli veri depolama yöntemlerini kullanılmıştır.",
    "content": "<p>Tarihin çeşitli dönemlerinde çeşitli veri depolama yöntemlerini kullanılmıştır. İlk çağlarda bu, mağara duvarlarına çizilen resimler, kil tabletlere yazılan hiyeroglifler, sonraki dönemlerde değişen hayat şartlarıyla hayvan derilerine yazılmış yazılar ve kağıt ve matbaanın icadıyla kitaplar ve dosyalar şeklinde gelişim göstermiştir. O zaman için bunlar günlük hayatı etkileyen büyük keşifler olsa bile veri depolamaya dair asıl dönüm noktası elektronik hesaplama cihazlarının gelişmesiyle başlamıştır. İlk bilgisayar sistemlerinde ağırlıklı olarak manyetik diskler, drum bellekler ve manyetik şeritler üzerine kaydetme yöntemleri, mikrobilgisayarların yaygınlaşmasıyla floppy diskler ve ardından optik diskler (CD, DVD), sabit disklerin veri depolama kapasitesinin artmasıyla SSD’ler, USB bellekler, veritabanı yönetim sistemleri ve bulut depolama hizmetleri veri depolama ihtiyacını karşılamıştır. Zamanla gelişen bu sistemlerin temelinde artan verilerin nasıl yönetileceği sorusu etkili olmuştur. Veritabanı sistemleri de aynı ihtiyaçlar doğrultusunda geliştirilen sistemlerden biridir.</p><p>Veritabanı (database), verilerin düzenli ve birbiriyle ilişkili bir şekilde saklandığı, yönetildiği ve erişildiği bir sistemdir. İlişkisel (SQL) veya ilişkisel olmayan (NoSQL) sistemler olabilir. Veritabanları, çeşitli uygulamalarda veri yönetimini kolaylaştırmak için kullanılır.</p><p>Veritabanı yönetim sistemi (database management system), veritabanları oluşturmak, saklamak, çoğaltmak, güncellemek, yönetmek ve erişmek için kullanılan kullanılan programlardır. MySQL, PostgreSQL, Oracle, MongoDB, Microsoft Access, IBM DB2, Informix, Progress ve Microsoft SQL Server yaygın olarak kullanılan veritabanı yönetim sistemleridir.</p><p>Veritabanı yönetim sistemlerinin getirdiği çeşitli avantaj vardır.</p><ul><li>Verinin tutarlılığını, doğruluğunu ve güvenliğini sağlayarak, veri bütünlüğünü korur.</li><li>Kullanıcı yetkilendirmeleri, şifreleme, yedekleme ve kurtarma gibi özellikler sunarak, verinin yetkisiz erişimden korunmasını yani verinin güvenliğini sağlar.</li><li>Verinin tutarlı ve standart bir şekilde yapılandırılmasını (veri standardizasyonu) ve depolanmasını mümkün kılar.</li><li>Farklı kaynaklardan gelen verileri tek bir sistem üzerinde bütünleştirerek veri entegrasyonu sağlar.</li><li>Aynı anda birden fazla kullanıcının veriye erişimini ve güncellemesini sağlar ve gerçek zamanlı işlemler yapılmasını veya kararlar alınmasını destekler.</li><li>Verilere hızlı erişim, sorgulama ve raporlama imkanı sunar.</li><li>Fiziksel veri depolama yapısından bağımsız olarak, mantıksal veri modellemesi sağlar yani veri bağımsızlığını sağlar.</li><li>Düzenli yedekleme ve hızlı kurtarma özellikleriyle veri kaybını önler.</li><li>Artan veri ve kullanıcı ihtiyaçlarına göre ölçeklenebilir bir yapı sunar.</li><li>Veritabanı üzerindeki işlemlerin izlenmesi, raporlanması ve yönetilmesini kolaylaştırır.</li></ul><p>Çeşitli veritabanı yönetim sistemleri ve özelliklerini inceleyelim:</p><ul><li><strong>Access:</strong> MS Office ürünüdür. Küçük ölçekli uygulamalar içindir. Tablo başına 2 GB’a kadar veri depolayabilir. Aynı anda 255 bağlantıya izin verebilir. Windows işletim sistemleri dışında kullanılamaz.</li><li><strong>MySQL:</strong> açık kaynak kodludur. Her türlü işletim sistemlerinde çalışır. Tablo başına 4 TB veri depolayabilir.</li><li><strong>Sql Server (MySQL):</strong> Microsoft ürünüdür. Sadece Windows üzerinde çalışır. Yüksek maliyetlidir. Orta ve büyük ölçekli işlemler için kullanılır. Tablo başına 4 TB veri depolayabilir. Gelişmiş özelliklere sahiptir.</li><li><strong>Informix:</strong> Illustra firması tarafından geliştirildi ve 2001 yılında IBM tarafından satın alındı. Ücretli ve güçlü bir veritabanıdır. Orta ölçekli işletmelerin yükünü kaldırabilecek kapasitedir.</li><li><strong>IBM DB2:</strong> IBM ürünüdür. Her türlü işletim sisteminde çalışır. Gelişmiş özelliklere sahiptir.</li><li><strong>PostgreSQL:</strong> Her türlü işletim sisteminde çalışır. Ücretsiz, açık kaynak kodludur. Tablo başına 64 TB veri depolamaya sahiptir. Çok güçlü işlem yapısı ve gelişmiş özelliklere sahiptir.</li><li><strong>Oracle:</strong> Oracle firması tarafından geliştirilmiştir. Dünyanın en güçlü ve en güvenilir veritabanıdır. Her türlü işletim sisteminde çalışır. Çok yüksek ölçekli uygulamalar için tercih edilir. Oluşturulabilecek tablo sayısı sınırsızdır. Maliyeti yüksektir.</li></ul><p><strong>Tablo (table),</strong> veritabanında verilerin depolandığı temel yapıdır. Tablo, satırlar (kayıtlar) ve sütunlardan (alanlar) meydana gelir. Her sütun belirli bir veri türünü içerir. Bir veritabanında birden fazla tablo bulunabilir.</p><p><strong>Kayıt (row/record),</strong> tablo içindeki her bir satırdır. Her satır, bir varlık hakkında bilgi içerir. Örneğin, bir müşteri kaydı, müşteri adı, adresi ve telefon numarasını içerebilir.</p><p><strong>Alan (column/field),</strong> tablo içindeki her bir sütundur. Her sütun, farklı veri türlerinde veri içerebilir. Örneğin isimler karakter tipini, numara bilgileri sayısal veri tiplerini, doğum tarihleri ise tarih veri tiplerini kullanır. Bir veri tabanı oluşturulurken öncelikle tablo, sütunlar ve tabloya ait veri tipleri tanımlanır.</p><p><strong>Anahtar (key),</strong> veritabanındaki kayıtları benzersiz bir şekilde tanımlamak için kullanılır. Veritabanlarında iki çeşit anahtar vardır: Birincil anahtar (primary key) ve ikincil anahtar (foreign key).</p><ul><li><strong>Birincil anahtar (primary key),</strong> her satırın benzersiz olarak tanımlanmasını sağlar. Bir tablo yalnızca bir tane birincil anahtar içerebilir. Birincil anahtar, kişinin TC kimlik numarası, telefon numarası, okul numarası, e-posta adresi, parmak izi, banka kartı numarası gibi her bir kayıt için eşsiz değeri ifade etmelidir.</li><li><strong>İkincil anahtar (foreign key),</strong> aynı veritabanındaki başka bir tabloda birincil anahtara referans vererek iki tablo arasında ilişki kurmayı sağlar.</li></ul><p><strong>İlişki (relationship),</strong> veritabanındaki iki veya daha fazla tablo arasındaki bağlantıdır. İlişkiler genellikle dört türde sınıflandırılır:</p><ul><li>One-to-one (1–1): 1’den 1’e ilişkiyi ifade eder. Her kayıt diğer tablodaki bir kayıtla eşleşir.</li><li>One-to-many (1 — N): 1’den çok’a ilişkiyi ifade eder. Bir kayıt diğer tablodaki birden fazla kayıtla eşleşir.</li><li>Many-to-one (N — 1): Çok’tan 1’e ilişkiyi ifade eder. Birden fazla kayıt diğer tablodaki bir kayıtla eşleşir.</li><li>Many-to-many (N— M): Çok’tan çok’a ilişkiyi ifade eder. Her iki tablodaki kayıtlar birbirleriyle birden fazla eşleşme yapabilir.</li></ul><p><strong>Sorgu (query),</strong> veritabanı üzerinde çeşitli işlemler yapabilmeyi sağlayan komutlardır. Bu sorgular, veri alma, tablo oluşturma, veritabanı oluşturma, veri ekleme, veri silme, var olan bir veriyi değiştirme gibi birçok amaç doğrultusunda gerçekleştirilebilir. SQL (Structured Query Language), ilişkisel veritabanında kullanılan en yaygın sorgu dilidir.</p><p><strong>Veri modeli (data model),</strong> veritabanındaki verilerin yapısını ve ilişkilerini tanımlayan bir çerçevedir. İlişkisel, hiyerarşik, ağ ve nesne yönelimli veri modelleri gibi farklı türleri vardır.</p><p><strong>Veri bütünlüğü (data integrity),</strong> veritabanındaki verilerin doğruluğu ve tutarlılığı anlamına gelir. Veri bütünlüğü, çeşitli kurallar ve kısıtlamalarla sağlanır.</p><p><strong>Yedekleme ve kurtarma (backup and recovery),</strong> veritabanından veri kaybını önlemek için düzenli olarak yedeklenmesi ve bir sorun durumunda verilerin kurtarılması işlemleridir.</p><p><strong>Veri normalizasyonu (data normalization),</strong> veritabanı tasarımında veri tekrarını azaltmak ve veri bütünlüğünü sağlamak için kullanılan bir süreçtir. Normalizasyon, verilerin mantıklı bir şekilde yapılandırılmasını sağlar.</p>"
  },
  "github-conventional-commits": {
    "title": "GITHUB COMMIT STANDARDİZASYONU: CONVENTIONAL COMMITS",
    "summary": "Geçtiğimiz günlerde üzerinde çalıştığım bir otonom yapay zeka ajanı projesini GitHub’a yüklemeden önce aklıma bir soru geldi.",
    "content": "<p>Geçtiğimiz günlerde üzerinde çalıştığım bir otonom yapay zeka ajanı projesini GitHub’a yüklemeden önce aklıma bir soru geldi. Her seviyeden geliştiriciye özgürce hata yapma özgürlüğü veren Git sayesinde, projede yaptığımız herhangi bir değişimi yönetebiliyor ve bunları commit mesajları ile kaydediyoruz. İyi ama bu kadar güçlü bir sistemin bütün büyüsünü, çoğu zaman ne anlattığı belirsiz veya baştan savma yazılmış commit mesajlarıyla bozduğumuzu hissetmiyor musunuz? Proje geçmişini gerçekten değerli kılan, herkesin anlayacağı temiz ve standart bir commit mesajı yazma kültürünü nasıl oluşturabiliriz?</p><p>Okullarda öğretilmediği için özellikle öğrenci ve genç arkadaşların beni anlayacağını düşünüyorum. Çünkü ben de, ne kadar önemsiz bir detay gibi görünse de, commit mesajlarına ne yazacağını bilemeyen ve zamanla karmaşık bir versiyon geçmişi içinde kaybolan biriydim. Kısa bir araştırmanın ardından, bu karışıklığa son veren ve yaygın olarak kullanılan bir standartla tanıştım: Conventional Commits.</p><p>Bu standardizasyon sayesinde kaotik commit geçmişimi bir kenara bırakıp okunabilirliği yüksek, takibi kolay ve basit bir mantıkla yönetilen commit’ler yazmaya başladım. Dahası, bu küçük değişiklik otomatik sürüm notu oluşturma (changelog) ve anlamsal sürümleme (semantic versioning) gibi konulardaki bilgimi de bir adım öteye taşıdı.</p><p>Bu yazıda, projenizin kalitesini artıracak “Conventional Commits” standardını tüm detaylarıyla ele alacağız.</p><p>Eğer benim gibi her küçük detayı önemseyip sık sık commit yapan biriyseniz, GitHub’ın otomatik “Updated /dosyaadi” mesajının ne kadar anlamsız olabildiğini bilirsiniz. Her commit, projeye yeni bir özellik eklemek ya da kritik bir hatayı çözmek anlamına gelmez. Bazen basit bir yazım hatasını düzeltiriz, bazen sadece kodun okunabilirliğini artıran bir formatlama yaparız, bazen de dokümantasyonu güncelleriz.</p><p>İşte Conventional Commits, bu farklılıkları temel alarak yaptığımız değişiklikleri anlamlı bir şekilde sınıflandırır. `fix`, `feat`, `docs`, `chore`, `refactor` gibi etiketlerle her yeni güncellemenin amacını ve kapsamını daha ilk bakışta net bir şekilde ifade etmemizi sağlar.</p><p>Bu sistemin standart şablonu şu şekildedir:</p><pre><code>&lt;type&gt;(&lt;optional scope&gt;): &lt;subject&gt;\n\n&lt;optional body&gt;\n\n&lt;optional footer&gt;</code></pre><p>Bu yapı; değişikliğin amacını belirten bir type, ne hakkında olduğunu özetleyen bir subject, tercihe bağlı olarak değişikliğin projenin hangi bölümünü etkilediğini gösteren bir scope ve daha detaylı açıklamalar için bir body metninden oluşur. Şimdi bu kavramları daha yakından inceleyelim.</p><h2>Type</h2><p>En yaygın kullanılan type’lar şunlardır:</p><h3>feat (Feature)</h3><p>Projenize yeni bir işlevsellik eklediğinizde kullanılır.</p><p>Örnek:</p><p>EN: feat: allow users to send voice commands<br>TR: feat: sesli komut gönderme özelliği ekle</p><h3>fix (Bug Fix)</h3><p>Kodunuzdaki bir hatayı (bug) düzelttiğinizde kullanılır.</p><p>Örnek:</p><p>EN: fix: correct the invalid response structure sent to the server<br>TR: fix: sunucuya gönderilen hatalı yanıt yapısını düzelt</p><h3>docs (Documentation)</h3><p>Yalnızca dokümantasyon dosyalarında (README.md gibi) veya koddaki yorum satırları/docstring’lerde yapılan değişiklikler için kullanılır.</p><p>Örnek:</p><p>EN: docs: add docstring for ‘validate_user’ function<br>TR: docs: ‘kullanici_dogrula’ fonksiyonuna docstring ekle</p><h3>style (Styling)</h3><p>Kodun anlamını veya çalışmasını etkilemeyen, sadece formatlama ve stil ile ilgili (boşluklar, noktalı virgüller, linter kuralları vb.) değişiklikler için kullanılır.</p><p>Örnek:</p><p>EN: style: rename function name according to PEP8 standards<br>TR: style: fonksiyon adını PEP8 standartlarına göre güncelle</p><h3>refactor (Code Refactoring)</h3><p>Bir hatayı düzeltmeyen veya yeni bir özellik eklemeyen, sadece mevcut kodun yapısını, okunabilirliğini veya mimarisini iyileştiren değişikliklerdir.</p><p>Örnek:</p><p>EN: refactor: modularize preprocessing logic into separate functions<br>TR: refactor: ön işleme mantığını modüler fonksiyonlara ayır</p><h3>test (Tests)</h3><p>Yeni testler eklediğinizde veya mevcut testleri güncellediğinizde kullanılır. Kaynak kodunda bir değişiklik içermez.</p><p>Örnek:</p><p>EN: test: add unit tests for user registration flow<br>TR: test: kullanıcı kaydı akışı için birim testleri ekle</p><h3>perf (Performance)</h3><p>Performansı artıran kod değişiklikleri için kullanılır.</p><p>Örnek:</p><p>EN: perf(db): optimize insert queries with batch processing<br>TR: perf(db): insert işlemlerini toplu sorgu ile iyileştir</p><h3>build (Build System)</h3><p>Projenin derleme sistemini, CI/CD süreçlerini veya dış bağımlılıklarını (örn: package.json, requirements.txt) etkileyen değişiklikler için kullanılır.</p><p>Örnek:</p><p>EN: build: update ‘requests’ dependency to version 2.31.0<br>TR: build: ‘requests’ bağımlılığını 2.31.0 sürümüne güncelle</p><h3>chore (Chores)</h3><p>Kaynak kodunu, testleri veya dokümantasyonu etkilemeyen, genellikle proje yönetimi veya yardımcı araçlarla ilgili rutin bakım işleridir.</p><p>Örnek:</p><p>EN: chore: add __pycache__ folder to .gitignore<br>TR: chore: __pycache__ klasörünü .gitignore’a ekle</p><h3>revert (Revert)</h3><p>Önceki bir commit’i geri alan bir değişikliği ifade eder. Genellikle ‘git revert’ komutu tarafından otomatik olarak oluşturulur.</p><p>Örnek:</p><p>EN: revert: feat(auth): add password reset functionality<br>TR: revert: feat(auth): “şifre sıfırlama işlevi ekle” commit’ini geri al</p><h2>Subject</h2><p>type’ı belirledikten sonra, değişikliği özetleyen kısa bir konu satırı yazılır. Bu bölümün en fazla 50 karakter olması ve emir kipiyle yazılması tavsiye edilir.</p><h2>Scope (Opsiyonel)</h2><p>Değişikliğin projenin hangi bölümünü etkilediğini belirtir. Bu, commit geçmişine bakıldığında değişikliğin nerede yapıldığını anlamayı çok kolaylaştırır.</p><p>Örnek:</p><p>EN: fix(api): add missing ‘user_id’ parameter to response<br>TR: fix(api): yanıttaki eksik ‘kullanici_id’ parametresini ekle</p><h2>Body (Opsiyonel)</h2><p>Eğer subject satırı değişikliği açıklamak için yetersiz kalıyorsa, bir satır boşluk bırakarak body kısmını doldurabilirsiniz. Burada değişikliğin “neden” yapıldığını ve ”nasıl” bir çözüm getirdiğini detaylandırabilirsiniz. Koddan ilk bakışta anlaşılamayacak bağlamı sağlamak için harikadır.</p><h2>Footer (Opsiyonel)</h2><p>Bu bölüm, meta verileri içindir.</p><ul><li><strong>İlişkili Görevler:</strong> Değişikliğin hangi görevle ilgili olduğunu belirtir (Jira, Trello, GitHub Issues vb.). Closes #45, Fixes JIRA-123 gibi anahtar kelimelerle ilgili görevi otomatik olarak kapatabilirsiniz.</li><li><strong>BREAKING CHANGE:</strong> Eğer yaptığınız değişiklik geriye dönük uyumluluğu bozuyorsa (örneğin, bir API endpoint’inin yapısını değiştirdiyseniz), bunu mutlaka bir BREAKING CHANGE: ön ekiyle footer’da açıklamanız gerekir.</li><li><strong>İşbirlikçiler:</strong> Kodu birlikte yazdığınız (Co-authored-by:) veya inceleyen (Reviewed-by:) kişileri belirtebilirsiniz.</li></ul><p>Bütün ögeleri kullandığımız detaylı bir Conventional Commits standartlarına uygun örnek bir commit mesajını aşağıda bulabilirsiniz.</p><pre><code>EN:\nfeat(auth): implement Google OAuth2 login\n\nAllows users to sign in with their Google accounts, not just with\nemail/password. This improves user experience and is expected to\nincrease registration rates.\n\nIntegration was completed using the 'passport-google-oauth20' strategy.\nCloses: #78\n\nBREAKING CHANGE: The '/auth/login' endpoint now expects a mandatory 'strategy'\nfield, which can be 'local' or 'google'.\n\nTR:\nfeat(auth): OAuth2 ile Google girişi ekle\n\nBu değişiklik, kullanıcıların standart e-posta/şifre yöntemine ek olarak\nmevcut Google hesaplarıyla platforma giriş yapmalarını sağlar. Bu yaklaşım,\nkayıt sürecini basitleştirerek kullanıcı deneyimini iyileştirir ve\nplatforma katılımı artırır.\n\nEntegrasyon, 'passport-google-oauth20' stratejisi kullanılarak\ngerçekleştirilmiştir.\n\nCloses: #78\n\nBREAKING CHANGE: '/auth/login' endpoint'i artık 'strategy' adında yeni bir\nzorunlu alan beklemektedir ('local' veya 'google' olabilir).</code></pre><h3>Kaynakça</h3><p><a href='https://www.conventionalcommits.org/en/v1.0.0/' target='_blank' rel='noopener noreferrer'>https://www.conventionalcommits.org/en/v1.0.0/</a></p>"
  }
}